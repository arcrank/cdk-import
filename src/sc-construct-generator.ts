import { pascal, camel } from 'case';
import * as j2j from 'json2jsii';
import { ProductDataAggregate } from './service-catalog';

/**
 * Generator to emit classes and information on provisioning details for a product.
 */
export class ServiceCatalogProvisioningConstructGenerator {
  private readonly productDataAggregate: ProductDataAggregate;
  private readonly hasParameters: boolean;
  private readonly sanitizedTypeName: string;
  private readonly resourceAttributes: string[];
  private readonly constructClassName: string;
  private readonly propsStructName: string;
  private readonly outputKeys: string[];
  public readonly name: string;

  /**
   * @param productData the aggregate details on a product with information on inputs and outputs of the template.
   */
  constructor(productData: ProductDataAggregate) {
    this.productDataAggregate = productData;
    this.sanitizedTypeName = pascal(this.productDataAggregate.product.Name!);
    this.constructClassName = j2j.TypeGenerator.normalizeTypeName(this.sanitizedTypeName);
    this.propsStructName = j2j.TypeGenerator.normalizeTypeName(`${this.constructClassName}Props`);
    this.name = this.sanitizedTypeName;
    this.resourceAttributes = new Array<string>();
    this.outputKeys = this.productDataAggregate.params.ProvisioningArtifactOutputKeys!.map(key => key.Key!);
    this.hasParameters = this.productDataAggregate.params.ProvisioningArtifactParameters!.length > 0;

    const attributeNames: string[] = [
      'provisionedProductId',
      'cloudFormationStackArn',
      'recordId',
      ...this.outputKeys.map(camel),
    ];

    for (const attr of attributeNames) {
      this.resourceAttributes.push(attr);
    }
  }

  /**
   * Render the type into a TypeScript class file defining the props and the wrapped L1 construct AWS::ServiceCatalog::CloudFormationProvisionedProduct.
   *
   * @returns the rendered class file content
   */
  public render(): string {
    const code = new j2j.Code();
    this.emitImports(code);
    this.emitInterface(code);
    this.emitBase(code);
    if (this.hasParameters) {
      this.emitParameterMap(code);
      this.emitDefinitionTypes(code);
    }
    this.emitConstructClass(code);
    return code.render();
  }

  private emitImports(code: j2j.Code) {
    code.line('// Generated by cdk-import');
    code.line("import * as cdk from 'aws-cdk-lib';");
    code.line("import * as constructs from 'constructs';");
    code.line("import * as sc from 'aws-cdk-lib/aws-servicecatalog';");
    code.line();
  }

  private emitInterface(code: j2j.Code) {
    code.openBlock(`export interface I${this.constructClassName} extends cdk.IResource`);
    this.resourceAttributes.forEach(attr => {
      code.line(`readonly ${attr}: string;`);
    });
    code.closeBlock();
    code.line();
  }

  private emitBase(code: j2j.Code) {
    code.openBlock(`abstract class ${this.constructClassName}Base extends cdk.Resource implements I${this.constructClassName}`);
    this.resourceAttributes.forEach(attr => {
      code.line(`public abstract readonly ${attr}: string;`);
    });
    code.closeBlock();
    code.line();
  }

  private emitParameters(code: j2j.Code) {
    code.line('  provisioningParameters:');
    code.line('    Object.entries(props).map(([k, v]) => {');
    code.line('      return {');
    code.line('        key: ParameterKeys.valueOf(k) as string,');
    code.line('        value: v as string,');
    code.line('      }');
    code.line('    }),');
  }

  private emitParameterMap(code: j2j.Code) {
    code.openBlock('enum ParameterKeys');
    this.productDataAggregate.params.ProvisioningArtifactParameters?.forEach(p => {
      code.line(`${camel(p.ParameterKey!)} = '${p.ParameterKey}',`);
    });
    code.closeBlock();
    code.line();
    code.openBlock('namespace ParameterKeys');
    code.line('const reverseMap = new Map<string, ParameterKeys>();');
    code.line('Object.keys(ParameterKeys).forEach((s: string) => {');
    code.line('  const e = (<any>ParameterKeys)[s];');
    code.line('  reverseMap.set(s, e);');
    code.line('});');
    code.line('export function valueOf(str: string) {');
    code.line('  return reverseMap.get(str);');
    code.line('}');
    code.closeBlock();
  }

  private emitDefinitionTypes(code: j2j.Code) {
    code.openBlock(`export interface ${this.constructClassName}Props`);
    this.productDataAggregate.params.ProvisioningArtifactParameters!.forEach(pa => {
      let optional = '';
      code.line('/**');
      (pa.Description != undefined) ? code.line(` * ${pa.Description}`): null;
      if (pa.DefaultValue) {
        optional += '?';
        (pa.ParameterConstraints?.ConstraintDescription != undefined) ? code.line(` * ${pa.ParameterConstraints?.ConstraintDescription}`): null;
        code.line(' *');
        code.line(` * @default ${pa.DefaultValue}`);
      }

      code.line(' */');
      code.line(`readonly ${camel(pa.ParameterKey!)}${optional}: ${pa.ParameterConstraints?.AllowedValues?.length ? pa.ParameterKey : 'string'};`);
      code.line();
    });
    code.closeBlock();
    code.line();
  }

  private emitConstructClass(code: j2j.Code) {
    code.line('/**');
    code.line(` * A Service Catalog CloudFormation \`${this.sanitizedTypeName}\` product.`);
    code.line(' *');
    code.line(' * @cloudformationResource AWS::ServiceCatalog::CloudFormationProvisionedProduct');
    code.line(' * @stability external');
    code.line(' */');
    code.openBlock(`export class ${this.constructClassName} extends ${this.constructClassName}Base`);
    for (const prop of this.resourceAttributes) {
      code.line('/**');
      code.line(` * Attribute \`${this.sanitizedTypeName}.${prop}\``);
      code.line(' */');
      code.line(`public readonly ${camel(prop)}: string;`);
    }
    code.line('private readonly provisionedProduct: sc.CfnCloudFormationProvisionedProduct;');
    code.line();

    code.line('/**');
    code.line(` * Create a new Service Catalog \`${this.sanitizedTypeName}\` product.`);
    code.line(' *');
    code.line(' * @param scope - scope in which this resource is defined');
    code.line(' * @param id    - scoped id of the resource');
    if (this.hasParameters) {
      code.line(' * @param props - resource properties');
    }
    code.line(' */');
    if (this.hasParameters) {
      code.openBlock(`constructor(scope: constructs.Construct, id: string, props: ${this.propsStructName})`);
    } else {
      code.openBlock('constructor(scope: constructs.Construct, id: string)');
    }
    code.line('super(scope, id);');
    code.line('');
    code.line("this.provisionedProduct = new sc.CfnCloudFormationProvisionedProduct(this, 'Resource', {");
    code.line('  provisionedProductName: this.node.id,');
    code.line(`  provisioningArtifactName: '${this.productDataAggregate.provisioningArtifact.Name!}',`);
    code.line(`  productName: '${this.productDataAggregate.product.Name!}',`);

    // generate provisioning parameters from props to avoid redundant defaults
    if (this.hasParameters) {
      this.emitParameters(code);
    };
    code.line('});');
    code.line();
    code.line('this.provisionedProductId = this.provisionedProduct.ref;');
    code.line("this.cloudFormationStackArn = cdk.Token.asString(cdk.Fn.getAtt(this.provisionedProduct.logicalId, 'CloudformationStackArn'));");
    code.line("this.recordId = cdk.Token.asString(cdk.Fn.getAtt(this.provisionedProduct.logicalId, 'RecordId'));");
    this.outputKeys?.forEach(output => {
      code.line(`this.${camel(output)} = cdk.Token.asString(cdk.Fn.getAtt(this.provisionedProduct.logicalId, 'Outputs.${output}'));`);
    });
    code.closeBlock();

    // Close construct class
    code.closeBlock();
  }
}